<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>SNEK</title>
	<style type = "text/css">
		canvas {
			width: 1024px;
			height: 720px;
		}
	</style>
    <script type="text/javascript" src="../dist/paper-full.js"></script>
    <script type="text/paperscript" canvas="canvas">
		var snek = new Path() //THE SNEK ITSELF!
		project.activeLayer.position = view.center; //IGNORE THIS IT'S SOME LEFTOVER CRAP FROM THE ORIGINAL FILE AND I DON'T KNOW WHAT IT DOES
		
		var inputDir 
		var currentTime 
		var gridSize 
		var snekLength
		var snekTailMoving
		var prevHeadNode //Define ALL the variables! 
		var prevTailNode 
		var nextHeadNode
		var nextTailNode
		var speedMul 
		
		//FILL IN THIS PART YOURSELF! How are you going to create a game state, like winning or losing? And how about a text object for the score, and a game over message? You'll need some variables!
		
		
		//FILL IN THIS PART YOURSELF! How can you create a 'fruit' for the snake to eat?
		
		
		reset();
		
		function reset(){
			inputDir = 'right' //this is the direction the snake is going to travel, based on the most recent input. It's distinct from currentDirVector because it can change a lot of times between when the game checks it.
			gridSize = 50; //Everything is hooked up to the grid size. Changing it will make a cascading change in a bunch of other variables, but only on startup. Not on runtime.
			snekLength = gridSize * 2; //We start off with a 3-segment snake- er, snek.
			nextHeadNode = new Point(snekLength*1.5,snekLength); //The snek head node is the bit that determines where the snek is headed. The node is copied at certain increments, and then it moves to a new location.
			snekHeadMoving = nextHeadNode.clone(); //This is the point that will be constantly changing while still inside the snek variable.
			snekTailMoving = new Point(0,snekLength); //And this is the point that will be constantly moving at the end of the snek, placed unintuitively at the beginning of the snek's point array. Deal with it.
			prevHeadNode = new Point(snekLength,snekLength); //this is the node that the moving snek head will extrude out from.
			prevTailNode = snekTailMoving.clone() //this is the node that the tail will be moving away from...
			nextTailNode = new Point(snekLength/2, snekLength) //and this is the node that the moving snek tail will shrink toward.
			speedMul = 2; //We start off at speed 2, for 1 'tick' every half second.
			
			snek.removeSegments() //Clearing out the snek before we begin.
			snek.strokeColor = 'black';
			snek.strokeWidth = gridSize * (4/5); //the snek doesn't extend all the way to the edge of its grid. Otherwise there wouldn't be any room to see its coils.
			snek.strokeCap = 'round';
			snek.strokeJoin = 'round';
			snek.add(snekTailMoving.clone()) //Manually adding in the 'moving tail'.
			snek.add(nextTailNode);//There will be two actual 'nodes' on the snake while it's at this length. This, and the clone of prevHeadNode below.
			snek.add(prevHeadNode.clone());
			snek.add(snekHeadMoving.clone()); //And the moving point. This point will never be removed and will stay forever at the end of the snek's point array.
			
			//FILL IN THIS PART YOURSELF! There should be some extra variables defined that will need to be reset every time the game is!
			
		}
		
		
		
		
		
		function onKeyUp(event) { //This event handler detects when keys are pressed.
			switch(event.key){
				case 'left' :
				case 'right' :
				case 'up' :
				case 'down' : //All directional key presses trigger the same code.
					inputDir = event.key;
					break; //Remember that case statements will continue down the lines of code until they hit a Break statement.
				case 'space' : //This is a placeholder function to show you how adding length to the snek should be done.
					snekLength += gridSize
					break;
				case 'y' :
					snek.strokeColor = 'yellow'; //Color changing is purely for show.
					break;
				case 'o' :
					snek.strokeColor = 'orange';
					break;
				case 'p' :
					snek.strokeColor = 'purple';
					break;
				case 'b' :
					snek.strokeColor = 'blue';
					break;
				case 'g' :
					snek.strokeColor = 'green';
					break;
				case 'k' :
					snek.strokeColor = 'black';
					break;
				case '1' :
				case '2' :
				case '3' :
				case '4' :
				case '5' :
				case '6' :
				case '7' :
				case '8' :
				case '9' :
					speedMul = parseInt(event.key) //Once again, all number keys trigger the same line of code. This will modify how fast we travel through nodes.
					break;
				//FILL IN THIS PART YOURSELF! What if you want to restart the game?
				
			}
			//console.log(inputDir);
		}
		function onFrame(event) {
			//FILL IN THIS PART YOURSELF! What if the game is over? 
			
			snek.removeSegment(snek.segments.length - 1) //each frame, the 'moving head' point has to be removed and refreshed.
			snek.removeSegment(0) //and the moving tail point.
			var measuredTime = Math.floor(event.time * speedMul) //this is where speedMul comes into play. It uses Floor to make movement easier to comprehend. progress to the next node is proportional to the adjusted raw time minus the floor time.
			if(currentTime != measuredTime){ //we've hit another time increment, which means we have to add the nextHeadNode clone to the snek path.
				currentTime = measuredTime //Updating the current time.
				snek.add(nextHeadNode.clone()) //The point at the end of the snek is always the moving one. So we insert the unmoving point, placed on the node, at the second-to-last spot.
				prevHeadNode = nextHeadNode.clone(); //We can get away with this because we haven't updated the 'next' head node yet.
				prevTailNode = nextTailNode.clone() //Same as above.
				snekHeadMoving = nextHeadNode.clone() //We also update the moving point position so that the moving point doesn't go anywhere stupid.
				snekTailMoving = prevTailNode.clone()
				//but where's the nextTailNode update? Down below. We need to see if we have to remove a node first.

				switch(inputDir) { //Check which direction was pressed last...
					case 'left':
						nextHeadNode.x -= gridSize; //The node travels ahead of us, marking our 'destination'.
						break;
					case 'right':
						nextHeadNode.x += gridSize;
						break;
					case 'up':
						nextHeadNode.y -= gridSize;
						break;
					case 'down':
						nextHeadNode.y += gridSize;
						break;
				
				}
				var maxSegs = (snekLength / gridSize) + 1 //This is a crude way of measuring how many nodes the snake is supposed to cross at a time.
				var currentSegs = snek.segments.length //And this is how we measure how many nodes it's actually crossing. Remember that this does NOT include the 'moving' points.
				while(maxSegs <= currentSegs){
					snek.removeSegment(0); //removing the last segment. Remember that the moving tail segment has already been removed!
					currentSegs = snek.segments.length //updating each time so we don't get stuck in a loop.
				}
				nextTailNode = snek.firstSegment.point.clone() //And here we go, the tail node all set up. If the while loop doesn't remove any segments, the nextTailNode and prevTailNode will be identitcal. Plan for this!
				
			} else { //FILL IN THIS PART YOURSELF! How are you going to make the head and tail points move?
				
			}
			snek.add(snekHeadMoving) //regardless of what happens, we have to re-add the moving head and tail.
			snek.insert(0,snekTailMoving) //console.log(measuredTime);
			
			//FILL IN THIS PART YOURSELF! What also needs to be checked every frame?
			
			
		}
		
		
        
    </script>
</head>
<body>
    <canvas id="canvas" resize></canvas>
</body>
</html>