<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Puzzle time!</title>
	<style type = "text/css">
		#canvas {
			width: 1024px;
			height: 720px;
			visibility: collapse;
		}
		td {
			border-width: 1px;
			border-color: black;
			border-style: solid;
		}
		tr {
			border-width: 1px;
			border-color: black;
			border-style: solid;
		}
		table {
			border-width: 1px;
			border-color: darkslateblue;
			border-style: solid;
		}
		#pset {
			visibility: collapse;
		}
		#cstm {
			visibility: collapse;
		}
	</style>
    <script type="text/javascript" src="../dist/paper-full.js"></script>
	<script type="text/javascript" src="piececlass.js"></script>
	<script type="text/javascript" src="setup.js"></script>	
    <script type="text/paperscript" canvas="canvas">
		
		/*
		var scaler = 100
		var puz = new Path() //The puzzle edge
		puz.strokeColor = 'black'
		puz.add(new Point(scaler,scaler), new Point(scaler+(Math.random()*scaler/4 - scaler/8),1.5*scaler+(Math.random()*scaler/4 - scaler / 8)), new Point(scaler,2*scaler))
		for (var i = 0; i < puz.segments.length; i++){
			puz.segments[i].handleOut = new Point((Math.random()*scaler/2)-(scaler/4), scaler/4)
			puz.segments[i].handleIn = new Point((Math.random()*scaler/2)-(scaler/4), -scaler/4)
		}
		var puz2 = new Path() //The second puzzle edge
		puz2.strokeColor = 'black'
		puz2.add(new Point(scaler,scaler), new Point(1.5*scaler+(Math.random()*scaler/4 - scaler/8),scaler+(Math.random()*scaler/4 - scaler / 8)), new Point(2*scaler,scaler))
		for (var i = 0; i < puz2.segments.length; i++){
			puz2.segments[i].handleOut = new Point(scaler/4, (Math.random()*scaler/2)-(scaler/4))
			puz2.segments[i].handleIn = new Point(-scaler/4, (Math.random()*scaler/2)-(scaler/4))
		}
		
		
		var pizzy = new Raster({
			source: 'JPizzle.jpg',
			position: view.center
		});
		pizzy.scale(0.5)
		circ1 = Path.Circle(new Point(480,300), 50)
		circ1.strokeColor = 'black'
		circ1.fillColor = 'blue'
		circ2 = Path.Circle(new Point(480,300), 50)
		circ2.strokeColor = 'black'
		circ2.strokeWidth = 10
		groupy = new Group([circ1, pizzy, circ2])
		groupy.clipped = true
		groupy.onMouseDrag = function(event){
			groupy.position += event.delta
		}
		 */ //group and puzzle geometry testing. Now for creating an actual grid!
		
		
		var xPieces = 5
		var yPieces = 5
		var xscaler 
		var yscaler
		var puzzlePieces = []
		var ras
		
		function puzzleBuilder(xscalerFunc, yscalerFunc, xPiecesFunc, yPiecesFunc){
			var upperLeftCorner = new Point(view.center.x - (ras.width / 2), view.center.y - (ras.height / 2)) //The raster appears in center stage. So we need the puzzle pieces to adapt to that.
			for(var i = 0; i < puzzlePieces.length; i++){
				puzzlePieces[i].remove() //Clearing out all existing objects inside it, just in case.
			}
			puzzlePieces = []
			var gid = 0
			for(var i = 0; i < xPiecesFunc; i++){
				for(var j = 0; j < yPiecesFunc; j++){
					var pieceMask = new Path.Rectangle(new Point(upperLeftCorner.x + (i * xscalerFunc), upperLeftCorner.y + (j * yscalerFunc)), new Point(upperLeftCorner.x + ((i + 1) * xscalerFunc), upperLeftCorner.y + ((j + 1)* yscalerFunc))) //Gonna add in more complicated geometry later.
					var pieceOutline = pieceMask.clone() //That SHOULD work?
					var pieceFill = ras.clone() //Each piece will have its own copy of the main picture, and damn the inefficiency.
					pieceMask.fillColor = new Color(1,1,1) //Fill the 'shape' so that it'll overlap properly, i hope.
					pieceOutline.strokeColor = 'black'
					pieceOutline.strokeWidth = 5 //And make a nice thick outline for the pieces.
					
					var pieceGroup = new Group([pieceMask, pieceFill, pieceOutline])
					pieceGroup.clipped = true
					
					var puzpiece = makePiece(pieceGroup, upperLeftCorner, gid, i, j)
					gid++
					moveAll(puzpiece, new Point(Math.random()*500 - 250, Math.random()*300-150))
					puzzlePieces.push(puzpiece)
				}
			}
			/*for(var i = 0; i < xPiecesFunc; i++){ //Well, THIS doesn't work.
				for(var j = 0; j < yPiecesFunc; j++){
					puzzlePieces[i][j].onMouseDrag = function(event){
						puzzlePieces[i][j].position += event.delta
					}
				}
			}*/
		}
		
		ras = new Raster({
			source: 'JPizzle.jpg',
			position: view.center
		});
		ras.onLoad = function(){
			xscaler = ras.width / xPieces
			yscaler = ras.height / yPieces
			console.log('puzzle piece width: ' + xscaler + ' puzzle piece height: ' + yscaler)
			puzzleBuilder(xscaler, yscaler, xPieces, yPieces)
			ras.visible = false
		}
		
		
		//Mouse behaviors...
		stage = document.getElementById("canvas")
		
		/*function clickBehavior(mevent){
			//console.log(mevent.pageX)
			for(var i = 0; i < puzzlePieces.length; i++){
				for(var j = 0; j < puzzlePieces[i].length; j++){
					if(puzzlePieces[i][j].firstChild.contains(new Point(mevent.pageX, mevent.pageY))){
						
					}
				}
			}
		}
		stage.addEventListener("mousedown",clickBehavior) */
		
		var movingPiece //gotta have this on hand to modify
		var mousePreviousLoc = new Point(0,0) //default values, YEAH
		var pieceCoords = 0
		var pieceStartLoc = new Point(0,0)
		var isDragging = false //boolean to keep a crap ton of error messages from appearing.
		function downBehavior(mevent){
			//console.log(mevent.pageX)
			for(var i = 0; i < puzzlePieces.length; i++){ //navigate through the puzzle piece array...
				for(var j = 0; j < puzzlePieces[i].groups.length; j++){
					if(puzzlePieces[i].groups[j].firstChild.contains(new Point(mevent.pageX, mevent.pageY))){ //This will only trigger when the outline of the puzzle piece contains the point.
						movingPiece = puzzlePieces[i] //SAVED for future abuse.
						pieceStartLoc = movingPiece.picPoint //Remember where we started...
						mousePreviousLoc = new Point(mevent.pageX, mevent.pageY) //and where the mouse was originally.
						pieceCoords = i
						i = puzzlePieces.length - 1 //now ABORT!
						j = puzzlePieces[i].groups.length - 1 //ABORT I SAY!
						isDragging = true //Drag mode: ON!
					}
				}
			}
		}
		stage.addEventListener("mousedown",downBehavior) //important to add the listeners to the stage.
		
		function moveBehavior(mevent){
			if(isDragging){ //Don't do nothing unless you're in drag mode!
				var mouseNewLoc = new Point(mevent.pageX, mevent.pageY)
				//console.log("Filler")
				moveAll(movingPiece, (mouseNewLoc - mousePreviousLoc)) //MATH for moving!
				mousePreviousLoc = mouseNewLoc
				//console.log(movingPiece.picPoint)
				puzzlePieces[pieceCoords] = movingPiece //And throw that back in there just in case that's how it works. I honestly have no idea but better safe than sorry.
			}
		}
		stage.addEventListener("mousemove",moveBehavior)
		function upBehavior(mevent){
			if(isDragging){
				moveBehavior(mevent) //May as well offload that functionality.
				
				movingPiece = new Item() //RESET so we don't screw with the wrong piece!
				mousePreviousLoc = new Point(0,0)
				pieceCoords = new Point(0,0)
				pieceStartLoc = new Point(0,0)
				isDragging = false //Drag mode: OFF!
				checkSnaps(puzzlePieces)
			}
		}
		stage.addEventListener("mouseup",upBehavior)
		
		
		
		function moveAll(piece, deltaPoint){ //I wanted to have this function as part of the piece class, but it needs to understand point logic, so it's here and I'm crying.
			for(var i = 0; i < piece.groups.length; i++){
				piece.groups[i].position += deltaPoint
			}
			piece.picPoint += deltaPoint
		}
		function checkSnaps(puzarray){ //This is our bread and butter! We've got to combine two pieces into one SUPERpiece.
			for(var i = 0; i < puzarray.length - 1; i++){
				for(var j = i + 1; j < puzarray.length; j++){
					if(puzarray[i].picPoint.getDistance(puzarray[j].picPoint) <= 10){
						//console.log("Puzzle snap logic triggered at " + i + ", " + j)
						var piece1 = puzarray[i] //save these locally so we don't have to muck with i, j things too much.
						var piece2 = puzarray[j]
						for(var i1 = 0; i1 < piece1.ipos.length; i1++){
							for(var i2 = 0; i2 < piece2.ipos.length; i2++){
								if(piece1.ipos[i1] == piece2.ipos[i2]){
									//console.log("i equality logic triggered!")
									//Now, here's the fiddly bit! We need to compare the SAME indexed j-positions for both pieces, and see if we get a near-match.
									//'But what about an exact match', I hear you ask? Well, in that case, we're somehow testing against ourselves.
									//Which is undesirable, in case you're wondering.
									if(Math.abs(piece1.jpos[i1] - piece2.jpos[i2]) == 1){
										console.log("SNAP triggered at " + i + ", " + j + "!")
										snap(puzarray, piece1, piece2)
									}
								}
								if(Math.abs(piece1.ipos[i1] - piece2.ipos[i2]) == 1){
									//console.log("i 1-difference logic triggered!")
									//And here, we compare the same-indexed I and J positions for the pieces and see if we get an equal match!
									if(piece1.jpos[i1] == piece2.jpos[i2]){
										console.log("SNAP triggered at " + i + ", " + j + "!")
										snap(puzarray, piece1, piece2)
									}
								}
							}
						}
					}
				}
			}
		}
		
		function snap(puzarray, puz1, puz2){
			var targ
			if(puz1.gid < puz2.gid){
				moveAll(puz1, (puz2.picPoint - puz1.picPoint))	
				for(var i = 0; i < puz2.groups.length; i++){
					puz1.groups.push(puz2.groups.pop())
					puz1.ipos.push(puz2.ipos.pop())
					puz1.jpos.push(puz2.jpos.pop())
				}
				targ = puzarray.indexOf(puz2)
			}else{
				moveAll(puz2, (puz1.picPoint - puz2.picPoint))
				for(var i = 0; i < puz1.groups.length; i++){
					puz2.groups.push(puz1.groups.pop())
					puz2.ipos.push(puz1.ipos.pop())
					puz2.jpos.push(puz1.jpos.pop())
				}
				targ = puzarray.indexOf(puz1)
			}
			puzarray.splice(targ, 1)
			
		}
		
    </script>
</head>
<body>
<form name="myForm" onsubmit="return puzSetup()">
		<table>
			<tr>
				<td>Pick a pic!
					<input type="file" id="puzzlimg" onchange="addNewPic()">
					<img src="" height="200" alt="Image preview...">
				</td>
				<td>
					<input type="radio" name="ptype" value="ps">Choose a preset size!
					<input type="radio" name="ptype" value="cs">Make your own dimensions!
					<input type="button" onclick="chooseTypeValues()" value="CLICK!">
				</td>
			</tr>
			<tr id="pset">
				<td>Choose the number of Rows x Columns you want your puzzle to have!
					<input list="presets" name="presets" onchange="updateSettings()">
					<datalist id="presets">
						<option value="2x2">
						<option value="4x6">
						<option value="5x5">
						<option value="6x4">
						<option value="8x12">
						<option value="10x10">
						<option value="12x8">
						<option value="16x20">
						<option value="20x16">
						<option value="20x20">
					</datalist>
				</td>
				<td>Choose an image size (the values listed refer to the longer side of the image)!
					<select name="presetimgsize" id="presetimgsize" onchange="updateSettings()">
						<option value="orgsz">Original Size
						<option value="200">200
						<option value="300">300
						<option value="400">400
						<option value="500">500
						<option value="600">600
						<option value="700">700
						<option value="800">800
						<option value="900">900
						<option value="1000">1000
						<option value="1100">1100
						<option value="1200">1200
						<option value="1300">1300
						<option value="1400">1400
						<option value="1500">1500
						<option value="1600">1600
					</select>
				</td>
			</tr>
			<tr id="cstm">
				<td>
    				<input type="number" name="rows" id="rows" min="1" max="50"></input>
				</td>
				<td>
    				<input type="number" name="columns" id="columns" min="1" max="50"></input>
				</td>
				<td>
    				<input type="number" name="width" id="width" min="50" max="2000"></input>
				</td>
				<td>
					<input type="number" name="height" id="height" min="50" max="2000"></input>
				</td>
			</tr>
		</table>
	</form>
    <canvas id="canvas" resize></canvas>
</body>
</html>